"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verifier = void 0;
var url = require("url");
var logger_1 = require("./logger");
var spawn_1 = require("./spawn");
var spawn_2 = require("./spawn");
var q = require("q");
var pact_standalone_1 = require("./pact-standalone");
var _ = require("underscore");
var checkTypes = require('check-types');
var unixify = require('unixify');
var fs = require("fs");
var path = require("path");
var util_1 = require("util");
var Verifier = (function () {
    function Verifier(options) {
        this.__argMapping = {
            pactUrls: spawn_2.DEFAULT_ARG,
            providerBaseUrl: '--provider-base-url',
            pactBrokerUrl: '--pact-broker-base-url',
            providerStatesSetupUrl: '--provider-states-setup-url',
            pactBrokerUsername: '--broker-username',
            pactBrokerPassword: '--broker-password',
            pactBrokerToken: '--broker-token',
            consumerVersionTag: '--consumer-version-tag',
            providerVersionTag: '--provider-version-tag',
            consumerVersionTags: '--consumer-version-tag',
            providerVersionTags: '--provider-version-tag',
            providerVersionBranch: '--provider-version-branch',
            consumerVersionSelectors: '--consumer-version-selector',
            publishVerificationResult: '--publish-verification-results',
            providerVersion: '--provider-app-version',
            provider: '--provider',
            enablePending: function (enablePending) { return [
                enablePending ? '--enable-pending' : '--no-enable-pending',
            ]; },
            customProviderHeaders: '--custom-provider-header',
            verbose: '--verbose',
            includeWipPactsSince: '--include-wip-pacts-since',
            monkeypatch: '--monkeypatch',
            format: '--format',
            out: '--out',
            logDir: '--log-dir',
            logLevel: '--log-level',
        };
        options = options || {};
        options.pactBrokerUrl = options.pactBrokerUrl || '';
        options.pactUrls = options.pactUrls || [];
        options.provider = options.provider || '';
        options.providerStatesSetupUrl = options.providerStatesSetupUrl || '';
        options.timeout = options.timeout || 30000;
        options.consumerVersionTag = options.consumerVersionTag || [];
        options.providerVersionTag = options.providerVersionTag || [];
        options.consumerVersionTags = options.consumerVersionTags || [];
        options.providerVersionTags = options.providerVersionTags || [];
        options.consumerVersionSelectors = options.consumerVersionSelectors || [];
        if (!_.isEmpty(options.consumerVersionTag) &&
            !_.isEmpty(options.consumerVersionTags)) {
            throw new Error("Must not use both 'consumerVersionTags' and 'consumerVersionTag'. Please use 'consumerVersionTags' instead");
        }
        if (!_.isEmpty(options.providerVersionTag) &&
            !_.isEmpty(options.providerVersionTags)) {
            throw new Error("Must not use both 'providerVersionTags' and 'providerVersionTag'. Please use 'providerVersionTags' instead");
        }
        if (options.consumerVersionTags &&
            checkTypes.string(options.consumerVersionTags)) {
            options.consumerVersionTags = [options.consumerVersionTags];
        }
        checkTypes.assert.array.of.string(options.consumerVersionTags);
        if (options.providerVersionTags &&
            checkTypes.string(options.providerVersionTags)) {
            options.providerVersionTags = [options.providerVersionTags];
        }
        checkTypes.assert.array.of.string(options.providerVersionTags);
        if (options.consumerVersionTag &&
            checkTypes.string(options.consumerVersionTag)) {
            options.consumerVersionTag = [options.consumerVersionTag];
        }
        checkTypes.assert.array.of.string(options.consumerVersionTag);
        if (options.providerVersionTag &&
            checkTypes.string(options.providerVersionTag)) {
            options.providerVersionTag = [options.providerVersionTag];
        }
        checkTypes.assert.array.of.string(options.providerVersionTag);
        if (!_.isEmpty(options.consumerVersionTag) ||
            !_.isEmpty(options.providerVersionTag)) {
            logger_1.default.warn("'consumerVersionTag' and 'providerVersionTag' have been deprecated, please use 'consumerVersionTags' or 'providerVersionTags' instead");
        }
        if (options.includeWipPactsSince !== undefined) {
            checkTypes.assert.nonEmptyString(options.includeWipPactsSince);
        }
        options.pactUrls = _.chain(options.pactUrls)
            .map(function (uri) {
            if (!/https?:/.test(url.parse(uri).protocol || '')) {
                try {
                    fs.statSync(path.normalize(uri)).isFile();
                    return unixify(uri);
                }
                catch (e) {
                    throw new Error("Pact file: " + uri + " doesn\"t exist");
                }
            }
            return uri;
        })
            .compact()
            .value();
        checkTypes.assert.nonEmptyString(options.providerBaseUrl);
        if (checkTypes.emptyArray(options.pactUrls) &&
            !options.pactBrokerUrl) {
            throw new Error('Must provide the pactUrls argument if no pactBrokerUrl provided');
        }
        if ((!options.pactBrokerUrl || _.isEmpty(options.provider)) &&
            checkTypes.emptyArray(options.pactUrls)) {
            throw new Error('Must provide both provider and pactBrokerUrl if pactUrls not provided.');
        }
        if (options.providerStatesSetupUrl) {
            checkTypes.assert.string(options.providerStatesSetupUrl);
        }
        if (options.pactBrokerUsername) {
            checkTypes.assert.string(options.pactBrokerUsername);
        }
        if (options.pactBrokerPassword) {
            checkTypes.assert.string(options.pactBrokerPassword);
        }
        if (options.pactBrokerToken &&
            (options.pactBrokerUsername || options.pactBrokerPassword)) {
            throw new Error('Must provide pactBrokerToken or pactBrokerUsername/pactBrokerPassword but not both.');
        }
        if (options.pactBrokerUrl) {
            checkTypes.assert.string(options.pactBrokerUrl);
        }
        if (options.pactUrls) {
            checkTypes.assert.array.of.string(options.pactUrls);
        }
        if (options.providerBaseUrl) {
            checkTypes.assert.string(options.providerBaseUrl);
        }
        if (options.publishVerificationResult) {
            checkTypes.assert.boolean(options.publishVerificationResult);
        }
        if (options.publishVerificationResult && !options.providerVersion) {
            throw new Error('Must provide both or none of publishVerificationResult and providerVersion.');
        }
        if (options.providerVersion) {
            checkTypes.assert.string(options.providerVersion);
        }
        if (options.format) {
            checkTypes.assert.string(options.format);
            if (options.format.toLowerCase() === 'xml') {
                options.format = 'RspecJunitFormatter';
            }
        }
        if (options.verbose === undefined && (0, logger_1.verboseIsImplied)()) {
            options.verbose = true;
        }
        if (options.out) {
            checkTypes.assert.string(options.out);
        }
        if (options.enablePending !== undefined) {
            checkTypes.assert.boolean(options.enablePending);
        }
        if (options.tags) {
            logger_1.default.warn("'tags' has been deprecated as at v8.0.0, please use 'consumerVersionTags' instead");
        }
        checkTypes.assert.positive(options.timeout);
        if (options.monkeypatch) {
            checkTypes.assert.string(options.monkeypatch);
            try {
                fs.statSync(path.normalize(options.monkeypatch)).isFile();
            }
            catch (e) {
                throw new Error("Monkeypatch ruby file not found at path: " + options.monkeypatch);
            }
        }
        this.options = options;
    }
    Verifier.prototype.verify = function () {
        logger_1.default.info('Verifying Pact Files');
        var deferred = q.defer();
        var instance = spawn_1.default.spawnBinary(pact_standalone_1.default.verifierFullPath, this.options, this.__argMapping);
        var output = [];
        instance.stdout.on('data', function (l) { return output.push(l); });
        instance.stderr.on('data', function (l) { return output.push(l); });
        instance.once('close', function (code) {
            var o = output.join('\n');
            code === 0 ? deferred.resolve(o) : deferred.reject(new Error(o));
        });
        return deferred.promise
            .timeout(this.options.timeout, "Timeout waiting for verification process to complete (PID: " + instance.pid + ")")
            .tap(function () { return logger_1.default.info('Pact Verification succeeded.'); });
    };
    Verifier.create = (0, util_1.deprecate)(function (options) { return new Verifier(options); }, 'Create function will be removed in future release, please use the default export function or use `new Verifier()`');
    return Verifier;
}());
exports.Verifier = Verifier;
exports.default = (function (options) { return new Verifier(options); });
//# sourceMappingURL=verifier.js.map